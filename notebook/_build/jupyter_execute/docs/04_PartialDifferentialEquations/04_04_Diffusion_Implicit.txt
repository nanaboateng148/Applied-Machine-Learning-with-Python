import numpy as np
import matplotlib.pyplot as plt

%matplotlib inline

plt.style.use('../styles/mainstyle.use')

import sys
sys.path.insert(0, '../modules')

# Euler step functions
from steppers import euler_step

# Function to compute an error in L2 norm
from norms import l2_diff

# Function to compute d^2 / dx^2 with second-order 
# accurate centered scheme
from matrices import d2_mat_dirichlet

# Function for the RHS of the heat equation and
# exact solution of our example problem
from pde_module import rhs_heat_centered, exact_solution

# Physical parameters
alpha = 0.1                    # Heat transfer coefficient
lx = 1.                        # Size of computational domain
ti = 0.0                       # Initial time
tf = 5.0                       # Final time

# Grid parameters
nx = 513                       # number of grid points
dx = lx / (nx-1)               # grid spacing
x = np.linspace(0., lx, nx)    # coordinates of grid points

# Time parameters
fourier = 0.49                      # Fourier number
dt = fourier*dx**2/alpha            # time step
nt = int((tf-ti) / dt)              # number of time steps

# Solution parameters
T0 = np.sin(2*np.pi*x)              # initial condition
source = 2*np.sin(np.pi*x)          # heat source term
sol = exact_solution(x, tf, alpha)  # Exact solution

T = np.empty((nt+1, nx)) # Allocate storage for the solution
T[0] = T0.copy()         # Set the initial condition

%%timeit
for i in range(nt):
    T[i+1] = euler_step(T[i], rhs_heat_centered, dt, dx, alpha, source)

diff_exact = l2_diff(T[-1], sol)
print(f'The L2-error made in the computed solution is {diff_exact}')
print(f'Time integration required {nt} steps')

# d^2 / dx^2 matrix with Dirichlet boundary conditions
D2 = d2_mat_dirichlet(nx, dx)     

# I+A matrix
M = np.eye(nx-2) + alpha*dt*D2

T[0] = T0.copy()         # Set the initial condition

%%timeit
for i in range(nt):
    T[i+1, 1:-1] = np.dot(M, T[i, 1:-1]) + source[1:-1]*dt

# Set the boundary values
T[-1,0] = 0.
T[-1,-1] = 0.

diff_exact = l2_diff(T[-1], sol)
print(f'The L2-error made in the computed solution is {diff_exact}')
print(f'Time integration required {nt} steps')

fourier = 10                   # Fourier number
dt = fourier*dx**2/alpha       # time step
nt = int((tf-ti) / dt)         # number of time steps

# I-A matrix
M = np.eye(nx-2) - alpha*dt*D2
Minv = np.linalg.inv(M)

T = np.empty((nt+1, nx)) # Allocate storage for the solution    
T[0] = T0.copy()         # Set the initial condition

%%timeit
for i in range(nt):
    T[i+1, 1:-1] = np.dot(Minv, T[i, 1:-1] + source[1:-1]*dt)

# Set boundary values
T[-1,0] = 0
T[-1,-1] = 0

diff_exact = l2_diff(T[-1], sol)
print(f'The L2-error made in the computed solution is {diff_exact}')
print(f'Time integration required {nt} steps')

fourier = 55              # Fourier number
dt = fourier*dx**2/alpha  # time step

nt = int((tf-ti)/dt)      # number of time steps

# I-0.5*A matrix + inverse
A = np.eye(nx-2) - 0.5*alpha*dt*D2
Ainv = np.linalg.inv(A)

# I+0.5*A matrix
B = np.eye(nx-2) + 0.5*alpha*dt*D2

# (I+0.5A)^{-1} * (I-0.5*A)
C = np.dot(Ainv, B)

T = np.empty((nt+1, nx)) # Allocate storage for the solution    
T[0] = T0.copy()         # Set the initial condition

%%timeit
scn = np.dot(Ainv, source[1:-1]*dt)
for i in range(nt):
    T[i+1, 1:-1] = np.dot(C, T[i, 1:-1]) + scn

# Set boundary values
T[-1,0] = 0
T[-1,-1] = 0

diff_exact = l2_diff(T[-1], sol)
print(f'The L2-error made in the computed solution is {diff_exact}')
print(f'Time integration required {nt} steps')

from IPython.core.display import HTML
css_file = '../styles/notebookstyle.css'
HTML(open(css_file, 'r').read())
